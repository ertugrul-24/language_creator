/**
 * Firebase Adapter Template
 * 
 * This file demonstrates how to implement the same language service functions
 * using Firebase (Firestore) instead of Supabase.
 * 
 * STATUS: TEMPLATE ONLY - Not implemented yet
 * Use: For reference when implementing Firebase support (Phase 1.4+)
 * 
 * STRUCTURE:
 * This adapter would:
 * 1. Implement same function signatures as Supabase adapter
 * 2. Use Firebase SDK instead of Supabase SDK
 * 3. Map Firebase-specific patterns to our domain models
 * 4. Be selected via environment variable: VITE_BACKEND=firebase
 * 
 * WHEN TO USE:
 * - After Supabase is stable
 * - When ready to support Firebase deployments
 * - For enterprise/production deployments on Google Cloud
 * 
 * REFERENCE ARCHITECTURE:
 * 
 * Supabase (SQL):
 * Database: PostgreSQL
 * - tables: languages, language_collaborators, dictionaries, grammar_rules, etc.
 * - queries: JOIN operations, transactions, ACID guarantees
 * - storage: Cloud storage buckets for files
 * 
 * Firebase (NoSQL):
 * Database: Firestore
 * - collections: /languages, /users, /dictionaries, /grammar_rules, etc.
 * - subcollections: /languages/{id}/collaborators, /users/{id}/activity, etc.
 * - storage: Cloud Storage for files
 * 
 * KEY DIFFERENCES:
 * 1. ID Generation:
 *    - Supabase: UUID (auto-generated by PostgreSQL)
 *    - Firebase: doc.id (auto-generated by Firestore)
 *    Both: No special handling needed
 * 
 * 2. Transaction Model:
 *    - Supabase: ACID transactions across tables
 *    - Firebase: Transaction API with write operations
 *    Impact: CreateLanguage needs multiple writes (language + collaborator)
 *    Solution: Use Firebase batch write or transaction
 * 
 * 3. Querying:
 *    - Supabase: SQL with JOINs
 *    - Firebase: Collection queries with filters
 *    Impact: getUserLanguages needs index setup
 *    Solution: Use composite indexes
 * 
 * 4. Data Structure:
 *    - Supabase: JSONB columns for complex data
 *    - Firebase: Nested objects in documents
 *    Example: language_specs stored as nested object in Firestore
 * 
 * IMPLEMENTATION PLAN:
 * 
 * Phase 1.4: Create Firebase Adapter
 * - Copy languageService.ts to firebaseLanguageService.ts
 * - Replace supabase client with firebase client
 * - Update each function to use Firebase SDK
 * - Add comprehensive error mapping
 * 
 * Phase 1.5: Adapter Pattern
 * - Create adapter interface
 * - Update languageService.ts to use adapter pattern
 * - Select adapter based on VITE_BACKEND environment variable
 * - No changes needed in components
 * 
 * Phase 1.6: Testing
 * - Test both adapters with identical test suite
 * - Document Firebase setup and RLS rules
 * - Create migration tools (Supabase â†” Firebase)
 */

import type { Language } from '@/types/database';
import type { LanguageSpecs } from '@/components/LanguageSpecsForm';

interface CreateLanguageInput {
  name: string;
  description: string;
  icon: string;
}

/**
 * PLACEHOLDER: Firebase implementation of createLanguage
 * 
 * Example structure (not yet implemented):
 * 
 * export const createLanguage = async (
 *   userId: string,
 *   input: CreateLanguageInput,
 *   specs?: Partial<LanguageSpecs>
 * ): Promise<Language> => {
 *   try {
 *     // 1. Validate inputs (same as Supabase)
 *     validateInputs(userId, input);
 *     
 *     // 2. Check for duplicates
 *     const query = db.collection('languages')
 *       .where('owner_id', '==', userId)
 *       .where('name', '==', input.name);
 *     const snapshot = await query.get();
 *     if (!snapshot.empty) {
 *       throw new Error('You already have a language with this name');
 *     }
 *     
 *     // 3. Create language document and collaborator record in transaction
 *     const newLanguageRef = db.collection('languages').doc();
 *     const languageId = newLanguageRef.id;
 *     
 *     return await db.runTransaction(async (transaction) => {
 *       // 3a. Create language document
 *       const languageData = {
 *         id: languageId,
 *         owner_id: userId,
 *         name: input.name.trim(),
 *         description: input.description.trim(),
 *         icon: input.icon,
 *         created_at: new Date(),
 *         updated_at: new Date(),
 *       };
 *       transaction.set(newLanguageRef, languageData);
 *       
 *       // 3b. Create collaborator record in subcollection
 *       const collabRef = newLanguageRef.collection('collaborators').doc(userId);
 *       transaction.set(collabRef, {
 *         user_id: userId,
 *         role: 'owner',
 *         joined_at: new Date(),
 *       });
 *       
 *       // 3c. Return the language
 *       return languageData as Language;
 *     });
 *   } catch (err) {
 *     console.error('[createLanguage-Firebase] Error:', err);
 *     throw err;
 *   }
 * };
 * 
 * NOTES ON ABOVE EXAMPLE:
 * 1. Transaction ensures both writes succeed or both fail
 * 2. Subcollection pattern: /languages/{id}/collaborators/{userId}
 * 3. Generated ID is available before write
 * 4. Similar validation and error handling as Supabase version
 */

export const createLanguageFirebase = async (
  userId: string,
  input: CreateLanguageInput,
  specs?: Partial<LanguageSpecs>
): Promise<Language> => {
  throw new Error(
    'Firebase adapter not yet implemented. Use Supabase for now. ' +
    'Firebase support will be added in Phase 1.4+'
  );
};

export const getUserLanguagesFirebase = async (userId: string) => {
  throw new Error('Firebase adapter not yet implemented');
};

export const getLanguageFirebase = async (languageId: string) => {
  throw new Error('Firebase adapter not yet implemented');
};

export const updateLanguageFirebase = async (
  languageId: string,
  updates: Partial<CreateLanguageInput>
) => {
  throw new Error('Firebase adapter not yet implemented');
};

export const deleteLanguageFirebase = async (languageId: string) => {
  throw new Error('Firebase adapter not yet implemented');
};

/**
 * FUTURE: Adapter Factory Pattern
 * 
 * This pattern would allow runtime selection of backend:
 * 
 * ```typescript
 * type BackendType = 'supabase' | 'firebase';
 * 
 * export const getLanguageAdapter = (backend: BackendType = 'supabase') => {
 *   switch (backend) {
 *     case 'supabase':
 *       return import('./supabaseLanguageService');
 *     case 'firebase':
 *       return import('./firebaseLanguageService');
 *     default:
 *       throw new Error(`Unknown backend: ${backend}`);
 *   }
 * };
 * 
 * // In languageService.ts:
 * const backend = import.meta.env.VITE_BACKEND || 'supabase';
 * const adapter = getLanguageAdapter(backend);
 * export { createLanguage: adapter.createLanguage };
 * ```
 */
